# Lunatic Labs Policies and Procedures

**Table of Contents**

[**The leader’s step-by-step guide**](#the-leaders-step-by-step-guide)

[**The developer’s step-by-step guide**](#the-developers-step-by-step-guide)

[The start of the project](#the-start-of-the-project)

[Working on Tasks](#working-on-tasks)

[Collaborate with the Team](#collaborate-with-the-team)

[**Communication expectations**](#communication-expectations)

[**Roles & Expectations**](#roles-expectations)

[Junior Developer](#junior-developer)

[Developer I](#developer-i)

[Developer II](#developer-ii)

[Lead Software Developer](#lead-software-developer)

[Software Project Manager](#software-project-manager)

[Software Architect](#software-architect)

[**Client Meeting Step by Step**](#client-meeting-step-by-step)

[1. Purpose](#1-purpose)

[2. Procedure](#2-procedure)

[**Starting a Jira setup**](#starting-a-jira-setup)

[1. Purpose](#1-purpose-1)

[2. Procedure](#2-procedure-1)

[**Logging Time on Jira**](#logging-time-on-jira)

[1. Purpose](#1-purpose-2)

[2. Procedure](#2-procedure-2)

[**Sprint Planning**](#sprint-planning)

[1. Purpose](#1-purpose-3)

[2. Procedure](#2-procedure-3)

[**Sprint Retrospective**](#sprint-retrospective)

[1. Purpose](#1-purpose-4)

[2. Procedure](#2-procedure-4)

[**GitHub Version Control**](#github-version-control)

[1. Purpose](#1-purpose-5)

[2. Scope](#2-scope)

[3. Responsibilities](#3-responsibilities)

[4. Procedure](#4-procedure)

[5. References](#5-references)

[6. Review & Revision](#6-review-revision)

[**Code Review Process**](#code-review-process)

[1. Purpose](#1-purpose-6)

[2. Scope](#2-scope-1)

[3. Responsibilities](#3-responsibilities-1)

[4. Procedure](#4-procedure-1)

[6. Review and Revision](#6-review-and-revision)

[7. Final Approval](#7-final-approval)

[8. Merge the Code](#8-merge-the-code)

[9. Post-Merge Activities](#9-post-merge-activities)

[**Documentation Management**](#documentation-management)

[1. Purpose](#1-purpose-7)

[2. Scope](#2-scope-2)

[3. Types of Documents](#3-types-of-documents)

[**Design Documentation**](#design-documentation)

[1. Purpose](#1-purpose-8)

[2. Scope](#2-scope-3)

[3. Procedure](#3-procedure)

[**Automated Testing Process**](#automated-testing-process)

[1. Purpose](#1-purpose-9)

[2. Scope](#2-scope-4)

[3. Procedure](#3-procedure-1)

[**Deployment**](#deployment)

[1. Purpose](#1-purpose-10)

[2. Scope](#2-scope-5)

[3. Procedure](#3-procedure-2)


## **The leader’s step-by-step guide**

* Understand and prepare the objectives, clients’ expectations, and timeline  
* Assess the individual's skill to assign responsibilities  
* Set up Jira and GitHub for the team   
* Conduct first team meeting  
  * Project expectations and outcomes   
  * Provide tools for learning such as online Github training or programming language quick courses.  
  * Share existing documentation or create new one  
  * Begin a sprint and create tasks (ensure tasks are not so big that they are not completed by the end of the sprint)   
  * A team leader should be able to ensure that everyone feels comfortable in their skills and the jobs they can do.

## **The developer’s step-by-step guide**

* Review the project’s goals and expected outcomes as explained by the team leader.  
  * Ask questions during the first meeting if anything is unclear.  
  * Learn about your responsibilities  
  * Clarify your tasks with the team leader if needed.  
  * Install and set up tools like GitHub, Jira, and any programming environment.  
  * Clone the project repository from GitHub and familiarize yourself with the code structure.

### **The start of the project**

* To get up to speed, you can use the provided learning resources (e.g., GitHub training and programming language tutorials).  
  * Focus on the project's tools and languages, such as C++ or Docker.  
  * Learn how to create branches, commit changes, and open pull requests on GitHub.  
  * Understand basic Git commands like git pull, git commit, and git push.

### **Working on Tasks**

* Look for tasks assigned to you in Jira.  
  * If a task seems too large or complex, discuss it with your team leader to break it into smaller steps.  
  * Focus on completing one small piece at a time, such as fixing a bug or creating a single function.

### **Collaborate with the Team** 

* **Ask for Help**:  
  * If you’re stuck, ask for guidance from a senior team member or your leader.  
  * Use Slack, team meetings, or code reviews to seek clarification.  
  * Submit your work for review and learn from feedback.  
  * Review others’ code if you feel confident; it’s a great way to learn best practices.  
* **Communication**:  
  * Update the Jira board to reflect your progress (e.g., move tasks from “In Progress” to “Done”).  
  * Before submitting your work, test it thoroughly to ensure it works as expected.  
  * Write clear and descriptive commit messages that explain what you’ve done  
  * Push your changes to the correct branch and open a pull request.  
    * Ensure your pull request includes a description of what you’ve done and any testing performed.  
* **Reflection:**  
  * Share what you learned, what you found challenging, and suggestions for improvement during sprint retrospectives.  
  * Apply feedback from code reviews and retrospectives to grow your skills  
  * Prioritize tasks to ensure they’re completed within the sprint timeline.  
  * Maintain notes on what you’ve worked on and any issues you faced for future reference.  
  * Volunteer for tasks when you’re done with your assigned work.  
  * Offer help if you notice others struggling with their tasks.

## **Communication expectations**

All team members must communicate issues, questions, and announcements through Slack, Jira, Github logs, and emails promptly and professionally.

**Slack**

* During work hours (Class time and/or Team Meetings), respond within 10-15 minutes whenever possible.  
* Outside of work hours (on campus during the week), responses should not exceed 30-45 minutes, unless occupied with class, extracurriculars, or studying.  
* If unable to respond immediately, send a brief message indicating your delay.  
* Off-site or commuting members should follow the same response time as on-site members outside work hours.  
* On off days (weekends, holidays, and/or inclement weather), response times may be longer, but direct @ mentions require prompt attention.

**Jira**

* Move tasks from “To Do” → “In Progress” when starting.  
* When ready for review, move to “In Review” and request feedback from a teammate.  
* After approval, move to “Done”.

![][image1]

**GitHub Logs**

* Document changes with clear and descriptive commit messages explaining what, how, and why the update was made.  
* Be specific about what you changed in the repo, and also explain how and why you changed or created a feature and fixed a bug.  
* This can be done in multiple ways, one of these being to commit comments.


**Emails**

* Check emails at least once or twice daily, including on weekends.  
* Professors and teammates may need urgent responses.  
  * 

## **Roles & Expectations**
The roles in Lunatic Labs include Junior Developer, Software Developer I/II, Lead Software Developer, Software Project Manager, and Software Architect. 

Students who are employed in Lunatic Labs can go up the hierarchy and get promoted through software studio courses listed in the following order:

* SENG 3233 (Software Studio I)  
* SENG 3243 (Software Studio II)  
* SENG 4233 (Software Studio III)  
* SENG 4243 (Software Studio IV)

### **Junior Developer**

* Someone who is enrolled in SENG 3233 (Software Studio I).   
* Junior developers will gain introductory experience in a wide range of application domains, tool stacks, and platforms.   
* They typically have the least experience in Software Studio, and it usually would be their first time working with Lunatic Labs.   
* Each week, they will be assigned at least one task by their Team leader to accomplish.   
* Typical Tasks include:  
  * Figma and Wireframe for prototype design  
  * Basic user interface design & frontend development  
  * Assisting Developer Is and IIs  
  * Basic programming


### **Developer I** 

* Someone who is enrolled in SENG 3243 (Software Studio II).  
* Each week, they will be assigned at least one task by their Team leader to accomplish.  
* They typically gain more programming and software knowledge than Junior Developers, making them more equipped to take on more responsibility.   
* Typical Tasks include:  
  * Figma and Wireframe for prototype design  
  * User interface design & frontend development  
  * Software testing and refactoring  
  * Backend development  
  * Assist in software architecture and infrastructure


### **Developer II** 

* Someone who is enrolled in SENG 4233 (Software Studio III).  
* Developer IIs typically build off of the same skills as Developer Is, but they have more experience and skill expertise in specific areas in software development.  
* Their team leader assigns them at least one task each week.  
* Typical Tasks include:  
  * UI/UX design  
  * Frontend development  
  * Backend development  
  * Software architecture & design   
  * Software construction  
  * Designing verification and validation approaches  
  * Additional responsibilities from a project management perspective


### **Lead Software Developer** 

* A potential path for a student enrolled in SENG 4243 (Software Studio IV).  
* Lead Software developers lead the developers I and II toward the completion of their projects.  
* They’re an all-rounder: both leading the charge on their project via Jira and working on the project themselves.   
* They continue to build on skills developed in previous projects, and they now can design and evaluate various Architecture and Design approaches.  
* Typical Tasks include:  
  * Planning sprints   
  * Hosts code reviews, sprint reviews, sprint retrospectives, and client meetings.  
  * Software automated testing   
  * Frontend development, backend development, system design, or all three  
  * Handling documentation and frameworks  
  * Testing and deployment of software  
  * Assigning tasks to members/filling the Jira backlog board  
  * Maintaining Jira board  
  * Reviewing and approving teammates’ Software Construction  
  * Implementing verification and validation approaches, including Continuous Integration and Delivery frameworks  
  * Responsibilities from a project management perspective

### **Software Project Manager**

* A potential path for a student enrolled in SENG 4243 (Software Studio IV).  
* Software project managers lead the developer Is and IIs toward the completion of their project, and they typically work on the Jira/Kanban board and backlog.  
* They have less actual software development work than other software developers and architects  
* Typical Tasks include:  
  * Managing project timelines, resources, and team coordination  
  * Assigning tasks to members/filling the Jira backlog board  
  * Knowing how to implement Agile, Scrum, or other development methodologies  
  * Assisting in starting and closing the sprint.  
  * Responsibilities from a project management perspective

### **Software Architect**

* A potential path for someone enrolled in SENG 4243 (Software Studio IV).  
* Software architects lead the developers Is and IIs toward the completion of their project, and they work on the software more often than on the Jira board.   
* Similar to what a lead software developer does, they can design and evaluate various Architecture and Design approaches.  
* Typical Tasks include:  
  * Creating system design strategies and selecting technologies.  
  * Guiding developers on design decisions and best coding practices.  
  * Enforcing coding standards, design patterns, and technical documentation.  
  * Having deep technical expertise in backend design/architecture, system architecture, frontend design patterns, and specific programming languages  
  * Reviewing and approving teammates’ Software Construction  
  * Implementing verification and validation approaches, including Continuous Integration and Delivery frameworks  
  * Responsibilities from a project management perspective

Before taking Software Studio I, students are required to take an introductory class called Intro to Software Engineering (SENG 2513). This is because before you start to become a junior developer, you need a basic understanding of:

* Software development life cycle  
  * Approaches to documentation  
  * Project management  
  * Software testing and verification  
  * Industry-standard tools that support software. 

## **Client Meeting Step by Step**

### **1\. Purpose** 

Client meetings are the stages where clear communication is established between the client and the team completing the project. 

### **2\. Procedure**

**Before the Meeting:**

* Understand the client’s objectives and how your project aligns with them.  
* Review any materials or briefs shared by the client. Prepare any questions or topics you’re expected to address.  
* Ensure that your assigned tasks are ready for presentation, if applicable.  
* Rehearse your points in simple, clear language.  
* Check-in with your teammates to align what will be presented and avoid redundancy.

**During the Meeting:**

*   Maintain good posture, make eye contact, and smile (it helps with tension).  
*   Write down key points, especially client requirements, deadlines, and feedback.  
*   If you’re meeting the client for the first time, briefly introduce yourself and your role in the project.   
*   If presenting, stick to what is relevant.  
*   Clarify requirements or seek more information about unclear aspects of the project.  
*   If a teammate forgets something or struggles to explain, provide help tactfully.

**After the Meeting:**

* Summarize the key points discussed, including requirements, deadlines, and action items.  
* If you were assigned to take notes, distribute them to the team through Slack, email, or your project management tool.  
* Update Jira or your to-do list based on new requirements or feedback received during the meeting.  
*  If something wasn’t clear during the meeting, ask your team lead or the client via email or Slack.  
* Begin or continue work on tasks discussed in the meeting. Prioritize any that the client emphasized.

## **Starting a Jira setup**

### **1\. Purpose** 

This SOP aims to outline the procedures for setting up Jira, which ensures efficient project management, issue tracking, task organization, collaboration, and customization of workflows. 

This platform is important for all software developers to create their projects. 

### **2\. Procedure** 

* Go to [https://www.atlassian.com/software/](https://www.atlassian.com/software/)   
* Sign in using your school email address and set up your account  
* Verify your email address and set up your account with a password and any required profile details.  
* Once signed in, you will be taken to your Atlassian dashboard.  
* Click on the Jira Software option among the available products.  
* Click on the Create Project button.

![][image2]

* Select a project template \- Scrum and provide a meaningful project name![][image3]  
* Once your project is created, invite members by entering their email addresses.  
* Familiarize yourself with the board layout. Common columns include Backlog, In Progress, Review, and Done.

## **Logging Time on Jira**

### **1\. Purpose** 

This SOP aims to outline the procedures for logging time to spend working on deliverables such as user stories, bugs, features, improvements, and other project-related tasks. 

All team members will be expected to “clock in” and report hours worked, including the specific tasks involved. 

### **2\. Procedure** 

1. Go to Apps \-\> Timesheet  
   ![][image4]  
2. Go to Calendar  
   ![][image5]  
   ---

     
3. Open the Relevant Issue  
   * Navigate to the specific issue for which you want to log time.  
   * Click on the issue to view its details.  
4. Locate the Time Tracking Section  
   * On the issue page, look for the "Work Log" section. This is usually found on the right-hand side or within the issue details, depending on your Jira layout.  
5. Initiate the Log Work Process  
   * Click the "Log Work" button or “+” button on the day you have worked.![][image6]  
6. Enter Time Spent  
   * Time Spent: In the pop-up or form that appears, enter the amount of time you spent on the task.  
   * Example formats include “2h 30m”, “1d”, or “45m”.  
   * Date Started: Confirm or adjust the start date/time if necessary. 

![][image7]

7. Save Your Work Log  
   * Once you’ve filled in the necessary details, click "Save" or "Log" to record your time entry.  
   * Your logged time should now appear in the issue’s work log or time-tracking section.  
8. Review Your Logged Time  
   * Verify that the logged time is correctly reflected in the issue details.

 


## **Sprint Planning** 

### **1\. Purpose** 

Sprint planning is an Agile environment that is designed to ensure that the team is aligned and prepared for the upcoming sprint.

### **2\. Procedure** 

Here are the specific steps involved in planning a sprint for each week:

1. Add new User Stories or Tasks to your Backlog and give them Story Points.    
1. Go to your project’s Jira board  
2. Go to the backlog of the Jira board  
3. Click the “create issue” button on either your current sprint or your backlog to create a new issue, and then click on that new issue **OR** click on an already existing issue.

   ![][image8]

4. Scroll down until you see “Story Point Estimate” under “Details”. Besides it, it should say “none”.   
5. Click on it to enter the number of story points you think the issue should be worth.  
   * Story Points should follow the Fibonacci sequence (1, 2, 3, 5\. Any higher, and the issue will be split into smaller ones)  
2. If a user story cannot be completed within one week, break it into smaller, manageable tasks.  
3. Prioritize the issues in your Backlog.  What’s most important to work on next?  
   * Review all issues and determine which are most important to work on next.  
   * Rank tasks based on importance.![][image9]  
4. Assign Tasks to Team Members  
   * Ensure each team member is assigned at least one issue they commit to completing during the sprint.  
   * Tasks should be small and clear enough to guarantee completion within the sprint.

   ![][image10]![][image11]

5. Tasks may include learning activities (ex. completing a tutorial or experimenting in a sandbox environment) to better understand the tools, language, or code base.  
   * After completing the learning activity, it is suggested to implement what you learned into the code  
     ![][image12]  
6. Begin the Sprint  
   * Once all tasks are assigned and prioritized, officially start the new sprint.  
   * Use Jira to track progress throughout the week.

## **Sprint Retrospective** 

### **1\. Purpose** 

The Sprint Retrospective meeting should occur after the Sprint Review is completed and before the next sprint begins.  

### **2\. Procedure**

Typically, the team answers three questions:

1. What work has been done well in this sprint?  
2. What work hasn’t been done well?  
3. What should we start doing to improve?

## **GitHub Version Control**

### **1\. Purpose** 

This Standard Operating Procedure (SOP) defines the GitHub workflow for managing version control, code collaboration, and repository best practices. 

It ensures that all developers follow a standardized process for maintaining project integrity, tracking changes, and collaborating efficiently.

### **2\. Scope** 

This SOP applies to all team members contributing to a project via GitHub. It includes guidelines on repository management, branching strategies, pull requests, code reviews, and issue tracking.

### **3\. Responsibilities** 

* **Developers**:  
  * Follow the GitHub workflow, including branching and pull request procedures.  
  * Regularly update their branches and resolve conflicts when necessary.  
  * Keep commitments meaningful and follow best practices for documentation.  
* **Reviewers:**  
  * Conduct thorough code reviews before merging changes.  
  * Ensure adherence to coding standards and project requirements.  
* **Project Maintainers**:  
  * Manage the repository structure, enforce workflow standards, and oversee merging strategies.  
  * Maintain documentation and ensure version control policies are followed.

 

### **4\.** **Procedure** 

**4.1 Setting Up GitHub Access**

1. **Create a GitHub Account:**  
   * Sign up at [https://github.com](https://github.com) if you don’t already have an account.  
2. **Request Repository Access:**  
   * The team lead or repository owner must invite new contributors.  
3. **Configure Git Locally:**  
   * Set up Git on your system:  
     git config \--global user. name "Your Name"  
     git config \--global user.email "your-email@example.com"  
4. **Clone the Repository:**  
   * Navigate to the repository and copy the clone URL.  
   * Run the following command: git clone \[repository URL\]

**4.2 Branching Strategy**

* **Main Branches:**  
  * Main: Production-ready code (no direct commits allowed).  
  * Develop: Active development, where feature branches are merged.  
* **Feature Branches:**  
  * Naming convention: feature/\[short-description\]  
  * Example:  
    git checkout \-b feature/login-authentication

**4.3 Committing and Pushing Changes**

1. **Check Out a Branch:**  
   git checkout \-b feature/new-feature  
2. **Make Changes and Stage Them:**  
   git add.  
3. **Write a Meaningful Commit Message:**  
   git commit \-m "\[Feature\] Login success"  
4. **Push to Remote Repository:**  
   git push origin feature/new-feature

**4.4 Work in Progress Commit**

For a work-in-progress commit, here are the steps to follow for the command line either in your bash terminal or in your VSCode terminal:

* Stage your changes: git add .  
* Put in a message to describe your commit:   
  git commit \-m “\[descriptive message\]”  
* Push to remote branch (optional): git push origin \<branch-name\>

After committing the feature, you should reset the branch if needed:

* git fetch origin main: fetches the latest changes and most recent updates from the remote main branch.  
  * git reset –soft origin/main: This resets your feature branch to match the latest commit from the remote main branch but preserves all your local changes in the staging/uncommitted area.

If you don’t want temporary commits cluttering your history, use git stash and git stash pop to restore your work later.

To do a work-in-progress commit in GitHub, follow these steps:

* Go to the page of the repository you're working on.  
* Click on the file you want to edit, or click the **"Add file"** button.  
* Click on the pencil icon in the upper right corner to edit it and make the necessary changes.  
* Scroll down to the **"Commit changes"** section.  
* In the **"Commit message"** box, enter your descriptive message about your progress.  
* Select **"Commit directly to the main branch"** or **"Create a new branch for this commit and start a pull request"**.  
* Click **“Commit changes”**

**4.5 Creating a Pull Request (PR)**

After committing, you should push your committed changes to the remote repository: git push origin “branch-name.”

Here are the steps:

1. Navigate to the GitHub repository.  
2. Click **"New Pull Request"** and select the correct branches.  
3. Add a **descriptive title** and **detailed description** of your changes.  
4. Assign reviewers and request feedback.  
5. Submit the PR and wait for approval.

To fetch the latest changes from the remote repository and merge them into your current local branch (the master branch), you would type git pull or git pull origin main in the command line.

**4.6 Code Review & Approval**

* **Reviewers must check:**  
  * Code readability and adherence to project standards.  
  * Functionality and potential bugs.  
  * Performance and security best practices.  
* **Approval Process:**  
  * Leave comments for required changes.  
  * If everything looks good, approve and merge the PR.

**4.7 Merging & Resolving Conflicts**

1. **Update Local Branch:**  
   git pull origin develop

**Resolve Conflicts:**

* Open conflicting files and manually resolve differences.  
2. **Push Resolved Changes:**  
   git add.  
   git push origin feature/new-feature \--force  
3. **Merge PR and Delete Branch:**  
   * Once approved, merge the branch via GitHub.  
   * Delete the branch locally and remotely:

     git branch \-d feature/new-feature

     git push origin \--delete feature/new-feature

**4.8 Keeping the Repository Clean**

* Delete old and merged branches regularly.

**4.9 Issue Tracking & Collaboration**

* **GitHub Issues:**  
  * Create new issues for bugs, tasks, or feature requests.  
  * Assign team members and add relevant labels.  
* **Document Discussions in Issues & PRs:**  
  * Keep project updates and decisions documented for future reference.

### **5\. References** 

* [GitHub Documentation](https://docs.github.com/)  
* [6 best practices review PRs Github](https://blog.mergify.com/6-best-practices-to-review-pull-requests-in-github/)

**5.1 GitHub Commands**

**Setup & Init**

* git init \- initialize an existing directory as a Git repository.  
* git clone \[url\] \- retrieve an entire repository from a hosted location via URL.

**Stage and Snapshot**

* git status \- show modified files in the working directory, staged for your next commit.  
* git add \[file\] \- add a file as it looks now to your next commit(stage).  
* git reset \[file\] \- unstage a file while retaining the changes in the working directory.  
* git diff \- diff of what is changed but not staged.  
* git diff \--staged \- diff of what is staged but not yet committed.  
* git commit \-m "\[descriptive message\]" \- commit your staged content as a new commit snapshot.  
* git push \- uploads changes and commits from the local repository to the remote repository  
* git pop \- moves shelved changes into their working directory  
* git stash \- saves and preserves changes without committing them yet

**Branch & Merge**

* git branch \- list your branches, a \* will appear next to the currently active branch.  
* git branch \[branch-name\] \- create a new branch at the current commit.  
* git checkout \-b \[branch-name\]  \- create a new branch based on the current HEAD  
* git checkout or git switch \[branch-name\] \- switch to another branch and check it out in your working directory.  
* git merge \[branch\] \- merge the specified branch's history into the current one.  
* git log \- show all commits in the current branch's history.  
* git pull \- fetch the latest changes from the remote repository and merge them into your current local branch (the master branch)  
* git fetch \- fetches the latest changes and most recent updates from a remote repository but does not merge into your current local branch  
* git rebase or git pull —rebase \- rewrites and tidies your branch history, using the current HEAD commit of the base branch as its base

### **6\. Review & Revision** 

This SOP will be reviewed every semester to ensure alignment with best practices and project requirements. Any updates should be added before each semester so that every new team or student can easily follow the steps.

## **Code Review Process** 

### **1\. Purpose** 

This SOP aims to establish a consistent and effective code review process to ensure code quality and team collaboration. 

This document outlines the procedures to be followed for preparing, reviewing, and merging code changes.

### **2\. Scope** 

This procedure applies to all developers working on any project. 

It covers the entire code review process from code submission to post-merge activities and is mandatory for every pull request (PR) that affects the codebase.

### **3\. Responsibilities** 

* **Developers:**  
  Prepare code for review, create pull requests, respond to feedback, and update PRs as needed.  
* **Reviewers:**  
  Conduct thorough reviews, provide constructive feedback, and approve or request changes.  
* **Team Leads:**  
  Ensure compliance with the SOP, facilitate communication, and monitor the code review process for continuous improvement.

####  

### **4\. Procedure** 

**4.1 Prepare Your Code for Review**

* **Push Your Changes:**  
  Commit your changes to your branch and push them to the remote repository.  
* **Create a Pull Request (PR):**  
  Open a PR with a clear title and a detailed description that explains what changes have been made and the rationale behind them.

**4.2 Assign Reviewers**

* **Select Reviewers:**  
  Assign team members who are knowledgeable about the affected modules or features.  
* **Notify the Team:**  
  Ensure that reviewers are promptly informed via the appropriate communication channels (e.g., Slack, email).

**4.3 Review the Code**

* **Examine the Diff:**  
  Review the changes line by line using your code review tool (e.g., GitHub, GitLab, Bitbucket).  
* **Evaluate Quality:**  
  * Ensure adherence to coding standards and best practices.  
  * Check that the code is clean, well-documented, and easy to understand.  
* **Assess Functionality:**  
   Confirm that the code meets the functional requirements and integrates seamlessly with the existing codebase.

**4.4 Run Tests**

* **Automated Testing:**  
   Verify that all automated tests pass within the CI/CD pipeline.   
* **Manual Testing:**  
   If applicable, perform manual tests to validate the new or modified functionality.

**4.5 Provide Constructive Feedback**

* **Comment Inline:**  
  Leave clear, specific comments directly on the code for sections that require improvement.  
* **Suggest Improvements:**  
  Provide actionable recommendations or code examples where necessary.  
* **Maintain a Positive Tone:**  
  Balance critique with positive feedback to reinforce good practices.

**4.6 Developer Response**

* **Address Feedback:**  
   Respond to review comments, clarify doubts, and make necessary changes.  
* **Update the PR:**  
   Push updates to the branch and reassign the PR for further review.

**4.7 Final Approval and Merging**

* **Re-Review:**  
   Once changes are made, reviewers re-assess the updated code.  
* **Approve or Request Further Changes:**  
   Approve the PR if all concerns are resolved or request additional modifications.  
* **Merge Strategy:**  
   Merge the code using the agreed strategy (e.g., merge commit, rebase, or squash) and close the PR.

**4.8 Post-Merge Activities**

* **Monitor Deployment:**  
   Ensure that the build and deployment process is successful and that no issues arise from the merged code.  
* **Reflect and Document:**  
   Record lessons learned and update this SOP if necessary for continuous improvement.

### **6\. Review and Revision** 

This SOP shall be reviewed annually or as needed to reflect changes in processes, tools, or team structures. 

All updates must be documented in the revision history and approved by the designated authority. 

* Address Feedback:  
  Review the comments, ask questions for clarification if needed, and make necessary changes.  
* Update the PR:  
  Push new commits to the branch to address the review comments.

### **7\. Final Approval** 

* Re-Review:  
  The reviewer(s) check the updated code to ensure that all concerns have been addressed.  
* Approve or Request Further Changes:  
  Approve the PR once satisfied or request additional modifications if necessary.

### **8\. Merge the Code** 

* Merge Strategy:  
  Use the defined merge method (e.g., merge commit, rebase, or squash) as per your team’s process.  
* Close the PR:  
  Once merged, close the PR and update the main repository accordingly.

### **9\. Post-Merge Activities** 

* Monitor Deployment:  
  Keep an eye on the build or deployment process to catch any issues.  
* Reflect:  
  Document lessons learned during the review process for future improvements.

## 

## **Documentation Management** 

### **1\. Purpose** 

Documentation Management is the process of capturing, storing, organizing, and managing digital documents within an organization. 

Many Document Management Software programs exist, but this article assumes that none of them will be used.

### **2\. Scope** 

According to [this website](https://www.aiim.org/what-is-document-imaging), some of the key features in document management include:

* Check-in/check-out and locking to coordinate the simultaneous editing of a document, so one person’s changes don’t overwrite another’s  
* Version control, so tabs can be kept on how the current document came to be and how it differs from the versions that came before (this can be done via Github)  
* Roll-back, or “activate” a prior version in case of an error or premature release (Again, this can be done via Github)  
* Audit trail to permit the reconstruction of who did what to a document during its life in the system (Can probably be done by GitHub or by the history tab in Google Docs)  
* Annotation and Stamps 	

For every relevant document (such as README files and our Standard Operating Procedures):

* The primary version should be stored in the project’s GitHub repository.  
* A Backup Version should be maintained as an independent, synchronized copy.  
* Whenever the document in GitHub is updated, the backup must also be updated, and vice versa.  
* Keeping all copies digital reduces storage requirements and facilitates efficient version control and sharing.

This strategy ensures that all important documents are consistently maintained, traceable, and readily available, enhancing both collaboration and accountability across the team.

### **3\. Types of Documents** 

**3.1 Document Creation**

1. Identify documentation needs (e.g., integration tests, software design, system tests).  
2. Incorporate diagrams, flowcharts, or code snippets when necessary.  
3. Maintain consistency in terminology and definitions across documents.

**3.2 Integration Test Documentation**

1. Define the scope and purpose of integration tests.  
2. Document test cases, expected outcomes, and dependencies.  
3. Include execution steps, sample data, and automation details.  
4. Ensure all integration points and APIs are covered.  
5. Provide error handling and troubleshooting guidance.

**3.3 Software Design & Organization Documentation**

1. Describe the system architecture, frameworks, and libraries used.  
2. Provide UML diagrams, entity-relationship models, or flowcharts.  
3. Document design decisions and their rationale.  
4. Define module interactions, dependencies, and APIs.  
5. Ensure documentation aligns with coding standards and best practices.

**3.4 System Test Documentation**

1. Outline system-wide test scenarios and objectives.  
2. Document system test cases, inputs, expected outputs, and acceptance criteria.  
3. Provide environment setup instructions (OS, databases, configurations).  
4. Include performance, security, and stress test documentation.  
5. Maintain logs of test executions, results, and bug reports.

**3.5 GitHub Repository Documentation**

1. Ensure each repo has a README.md file with project details.  
2. Provide contribution guidelines, coding standards, and branching strategy.  
3. Document deployment procedures and CI/CD pipelines.  
4. Include API references or configuration guides when applicable.

**3.6 Owner’s Manual & User Guides**

1. Provide clear step-by-step instructions for using the software/system.  
2. Include screenshots, GIFs, or video demonstrations if necessary.  
3. Document troubleshooting steps and FAQs.  
4. Ensure accessibility by using simple language and structured formatting.

**3.7 Visual Aids: Diagrams, Flowcharts, and Infographics**

1. Explain complex processes using UML diagrams, ER diagrams, flowcharts, and wireframes.  
2. Ensure that visuals are labeled clearly with legends where necessary.  
3. Store diagrams in vector formats (SVG, PNG, PDF) for clarity.  
4. Use tools like Lucidchart, Draw.io, PlantUML, or Visio.

**3.8 Readability and Accessibility Best Practices**

1. Use consistent formatting (headers, bullet points, tables)  
2. Write concisely and structured (avoid excessive jargon).  
3. Include a glossary for technical terms.  
4. Use table of contents and searchable formats (PDFs, HTML).

**3.9 Version Control & Updates**

1. Use version numbers (e.g., v1.0 for major releases, v1.1 for minor edits).  
2. Maintain a Document Revision Log to track changes.  
3. Schedule periodic document reviews (quarterly or bi-annually).  
4. Archive outdated documents while keeping a retrievable record.


## **Design Documentation**

### **1\. Purpose** 

Design Documentation is a collection of documents that cover what is important to your product and/or service. 

Design documentation keeps everyone involved in the project on the same page, ensuring that the project doesn’t go out of scope and that team members don’t invalidate each other’s work.

### **2\. Scope** 

Furthermore, [this site](https://www.atlassian.com/work-management/knowledge-sharing/documentation/software-design-document) explains that the following are essential parts of a good software design document:

* Introduction and overview  
* System architecture  
* Data design  
* Interface design  
* Component design  
* User interface design  
* Assumptions and dependencies  
* Glossary of terms

### **3\. Procedure** 

Design Documentation will be different for every team because each team will be working on something different, with different scopes and end goals.

However, according to the same website, creating a design document can undergo these general steps: 

* Gather requirements and initial information.  
* Outline the system architecture.  
* Detail the data design.  
* Specify the interface and component design.  
* Review and refine the document with stakeholders.

## **Automated Testing Process**

### **1\. Purpose**  

This SOP aims to establish guidelines and best practices for implementing automated testing within the software development lifecycle. 

Automated testing ensures software quality, efficiency, and reliability by reducing human error and speeding up the testing process.

### **2\. Scope**

This procedure applies to all software development teams involved in writing, executing, and maintaining automated test scripts for applications developed by the organization.

### **3\. Procedure** 

1. Identify the requirements, objectives, and test scope  
   * Define functional and non-functional requirements, performance benchmarks, and expected pass/success criteria.  
2. Find the appropriate testing framework and tools  
   * Selenium, PyTest, JUnit, assert() in C++, Curl, and Wget in webpages, etc.  
   * This depends on what programming language you use and the specific project needs.  
3. Create multiple test cases and scripts  
   * Unit tests that provide as much code coverage as possible.  
   * Provide tests meant to pass, fail, and meet edge cases  
   * Use a naming convention and standard format for test cases to ensure consistency, such as test\_featureName\_scenario.  
4. Test environment setup before implementation  
   * This could include web servers, hardware, OS, databases, and any machines, instruments, or third-party tools needed to perform the test.  
5. Build and run your code, execute tests, and ensure you get the correct outcome.  
6. If your output is not correct, tweak your code.   
   * Create a Jira assignment and assign it to a developer to fix the code.  
   * Conduct peer reviews  
   * Place your tests throughout the project for debugging to ensure correct output and correct errors.  
7. Analyze/review results  
   * Generate reports on results if needed  
   * Maintain test documentation to track progress  
8. Continue/repeat until all the tests output what you desire.  
   * Define a maintenance plan for updating test cases as the application evolves.

## **Deployment** 

### **1\. Purpose** 

Software Deployment is making software available to users and other software.  
   
Typically, individual members of a project team will ensure that their code works and then push it to Git Hub to integrate it with the rest of the software. 

### **2\. Scope** 

The team would then ensure that everything works together and iron out what doesn’t.

Once the build of the code is complete, one member of the team (probably but not always the team lead) will create a copy of the code to publish on a server or a physical computer. 

For example, the LUKE team deployed by zipping up the code used in the LUKE Kiosk, copying it to a flash drive, and then plugging that  drive into the physical Kiosk to update it.

### **3\. Procedure** 

To know the steps for deployment, each team should make a deployment checklist. 

The following is an example deployment checklist as found [here](https://www.ibm.com/docs/en/zos/3.1.0?topic=task-deploying-software):

The deployment checklist guides you through the following steps:

* Specify the name, description, and categories to use for the deployment.  
* Selecting the software to be deployed.  
* Selecting the objective of the deployment.  
* Generating reports that help you identify if SYSMODs are missing in the source software or any related instances.  
* Specify the data set names, catalogs, volumes, mount points, and SMP/E zone names to use for the target software.  
* Defining the settings to use for the deployment jobs and generating the jobs.  
* Submitting the deployment jobs and viewing the job output.  
* Specifying the name, description, and categories for the target software.
